import dotenv from 'dotenv';
import { build } from 'esbuild';
import fs from 'fs';
import path from 'path';
import { settings } from './settings';

// Load env from root
// const envPath = path.resolve(__dirname, '../../.env');
// const envConfig = dotenv.config({ path: envPath }).parsed || {};
// const SERVER_URL = envConfig.SERVER_URL || process.env.SERVER_URL || 'http://localhost:3099';
// const SELECTOR_ELEMENT = envConfig.SELECTOR_ELEMENT || process.env.SELECTOR_ELEMENT || '.submission-result-accepted';
// const NOTIFY_METHOD = envConfig.NOTIFY_METHOD || process.env.NOTIFY_METHOD || 'toast';
// const TOAST_TIMEOUT_MS = envConfig.TOAST_TIMEOUT_MS || process.env.TOAST_TIMEOUT_MS || '4000';
// const TOAST_POSITION = envConfig.TOAST_POSITION || process.env.TOAST_POSITION || 'bottom-right';

// console.log(`Building extension with SERVER_URL=${SERVER_URL}`);

// // 1. Generate settings.ts
// // Build a settings object by merging (in precedence): defaults <- existing file <- env/runtime values
// const settingsPath = path.resolve(__dirname, 'settings.ts');

// function tryReadExistingSettings(filePath: string) {
//   try {
//     if (!fs.existsSync(filePath)) return null;
//     const content = fs.readFileSync(filePath, 'utf8');
//     // Match the object literal after `export const settings =`
//     const m = content.match(/export\s+const\s+settings\s*=\s*({[\s\S]*?})\s*;/m);
//     if (!m) return null;
//     const objText = m[1];
//     // Safely evaluate the object literal. This assumes the object contains only literals.
//     // Wrap in parentheses to allow top-level object evaluation.
//     // Remove TypeScript-only tokens (like trailing commas are allowed in JS engine).
//     // Note: This is a pragmatic approach; if the file contains complex expressions this will fail.
//     const existing = Function('return (' + objText + ');')();
//     return existing;
//   } catch (e) {
//     console.warn('build.ts: failed to parse existing settings.ts, ignoring', e);
//     return null;
//   }
// }

// const existingSettings = tryReadExistingSettings(settingsPath) || {};

// const generatedFromEnv = {
//   serverUrl: SERVER_URL,
//   selectorElement: SELECTOR_ELEMENT,
//   notifyMethod: NOTIFY_METHOD,
//   toastTimeoutMs: Number(TOAST_TIMEOUT_MS),
//   toastPosition: TOAST_POSITION,
// };

// // Merge: start with existing (so user edits preserved), then override with env/generated values
// const finalSettings = Object.assign({}, existingSettings, generatedFromEnv);

// const settingsContent = `// This file is generated by build.ts
// export const settings = ${JSON.stringify(finalSettings, null, 2)};
// `;
// fs.writeFileSync(settingsPath, settingsContent);
// console.log('Generated src/settings.ts');



// 2. Generate manifest.json
const templatePath = path.resolve(__dirname, '../manifest.json.template');
let manifestContent = fs.readFileSync(templatePath, 'utf8');
manifestContent = manifestContent.replace(/\{\{SERVER_URL\}\}/g, settings.serverUrl);
const manifestPath = path.resolve(__dirname, '../manifest.json');
fs.writeFileSync(manifestPath, manifestContent);
console.log('Generated manifest.json');

// 3. Bundle with esbuild
build({
  entryPoints: [path.resolve(__dirname, 'content.ts')],
  outfile: path.resolve(__dirname, '../dist/content.js'),
  bundle: true,
  platform: 'browser',
  target: ['chrome100'],
})
  .then(() => {
    console.log('Bundled dist/content.js');
  })
  .catch(() => process.exit(1));
